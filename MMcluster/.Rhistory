if (!mu.fixed){
# Update mu, a 'K x p' matrix of class averages of theta
new_mu <- update_mu(new_theta, old_mu, old_Sigma, old_z)
}
if(!Sigma.fixed){
# Update Sigma, a 'p x p x K' array of covariance matricies
new_Sigma <- update_Sigma(data, new_theta, new_mu, old_Sigma, old_z, Omega, Vk)
}
if(!rho.fixed){
# Update rho, a K x 1 vector
new_rho <- update_rho(new_theta, new_mu, new_Sigma, old_z)
}
if (!z.fixed){
# Update z, an N x 1 vector
new_z <- update_z(new_theta, new_mu, new_Sigma, new_rho)
}
# Store theta and z values if desired
if (m > burnin_period){
curIdx<- m - burnin_period
if (Theta.out){
Theta[, , curIdx] <- new_theta
}
if (z.out){
z[, curIdx] <- new_z$z
}
rho[ ,curIdx]<- new_rho
mu[ , ,curIdx]<- new_mu
Sigma[ , , ,curIdx]<-  new_Sigma
total_Lambda <- total_Lambda + new_z$Lambda
}
# Update all values
old_theta <- new_theta
old_mu <- new_mu
old_Sigma <- new_Sigma
old_rho <- new_rho
old_z <- new_z$z
}
total_Lambda <- total_Lambda / numIter
return(list(theta=Theta, mu=mu, Sigma=Sigma, rho=rho, z=z, Lambda=total_Lambda))
}
## Comparing Gibbs Sample and Posterior Distribution
mu_o <- array(runif(K*p)*sample(1:5, K*p, replace=TRUE), dim =c(K, p))
init_vals<-list(rho=rho, V=V, z=Z, theta=theta, Sigma=Sigma, mu = mu_o, vk = vk )
system.time({
Theta<-MMcluster(y, V, initParamVals = init_vals, K = K, burnin_period= 100, numIter = 1000)
})
hist(Theta$mu[,5,1], breaks = 100, freq = FALSE,
xlab = expression(mu),
main = expression(p(mu*" | "*Sigma,V,theta,rho,bold(z),bold(y))))
Theta$mu
K<-3
N<-100
p<-3
num_sim =10
data<- sim_data(K, N, p)
rho <- data$rho
y <- data$y
V <-data$V
Z <- data$Z
theta <- data$theta
mu <-data$mu
Sigma <-data$Sigma
vk<-data$vk
Omega<-data$Omega
rand_idx<- as.integer(K*runif(1))
ldu<-rep(0, num_sim)
lld<-rep(0, num_sim)
for ( i in 1: num_sim){
mu[rand_idx,]<- runif(p)
ldu[i]<- nnm_post(mu, Sigma, rho[,1], y, V, theta, Z, vk, Omega)
lld[i] <- mu_k.post(theta, mu, Sigma, Z, rand_idx)
}
lld-ldu
## Comparing Gibbs Sample and Posterior Distribution
mu_o <- array(runif(K*p)*sample(1:5, K*p, replace=TRUE), dim =c(K, p))
init_vals<-list(rho=rho, V=V, z=Z, theta=theta, Sigma=Sigma, mu = mu_o, vk = vk )
system.time({
Theta<-MMcluster(y, V, initParamVals = init_vals, K = K, burnin_period= 100, numIter = 1000)
})
hist(Theta$mu[,5,1], breaks = 100, freq = FALSE,
xlab = expression(mu),
main = expression(p(mu*" | "*Sigma,V,theta,rho,bold(z),bold(y))))
Theta$mu
hist(Theta$mu[,3,1], breaks = 100, freq = FALSE,
xlab = expression(mu),
main = expression(p(mu*" | "*Sigma,V,theta,rho,bold(z),bold(y))))
analytic_params <- mu_k_marginals.param(theta, 1, Sigma, Z, 3)
curve(dnorm(x = x, mean = analytic_params$mean, sd = analytic_params$sd), add = TRUE, col = "red")
analytic_params <- mu_k_marginals.param(theta, 1, Sigma, Z, 5)
analytic_params <- mu_k_marginals.param(theta, 2, Sigma, Z, 3)
curve(dnorm(x = x, mean = analytic_params$mean, sd = analytic_params$sd), add = TRUE, col = "red")
hist(Theta$mu[,3,1], breaks = 100, freq = FALSE,
xlab = expression(mu),
main = expression(p(mu*" | "*Sigma,V,theta,rho,bold(z),bold(y))))
analytic_params <- mu_k_marginals.param(theta, 1, Sigma, Z, 3)
curve(dnorm(x = x, mean = analytic_params$mean, sd = analytic_params$sd), add = TRUE, col = "red")
hist(Theta$mu[,3,2], breaks = 100, freq = FALSE,
xlab = expression(mu),
main = expression(p(mu*" | "*Sigma,V,theta,rho,bold(z),bold(y))))
analytic_params <- mu_k_marginals.param(theta, 2, Sigma, Z, 3)
curve(dnorm(x = x, mean = analytic_params$mean, sd = analytic_params$sd), add = TRUE, col = "red")
hist(Theta$mu[,3,3], breaks = 100, freq = FALSE,
xlab = expression(mu),
main = expression(p(mu*" | "*Sigma,V,theta,rho,bold(z),bold(y))))
analytic_params <- mu_k_marginals.param(theta, 3, Sigma, Z, 3)
curve(dnorm(x = x, mean = analytic_params$mean, sd = analytic_params$sd), add = TRUE, col = "red")
usethis::use_testthat()
usethis::use_test()
usethis::use_test()
library(testthat)
?context
?test_that
test_that("mu posterior", {
expect_equal(lld-ldu)
})
all.equal(lld - ldu)
?identical
identical(lld - ldu)
?expect
# iterate through all values of difference and make sure
# they are equal to the first value
for (diff_i in difference) {
test_that("mu posterior", {
expect_equal(diff_i, difference[1])
})
}
difference <- lld-ldu
# iterate through all values of difference and make sure
# they are equal to the first value
for (diff_i in difference) {
test_that("mu posterior", {
expect_equal(diff_i, difference[1])
})
}
devtools::install()
testthat::test_package("MMcluster", reporter = "progress")
devtools::install()
testthat::test_package("MMcluster", reporter = "progress")
devtools::install()
testthat::test_package("MMcluster", reporter = "progress")
devtools::install()
testthat::test_package("MMcluster", reporter = "progress")
devtools::install()
testthat::test_package("MMcluster", reporter = "progress")
devtools::install()
testthat::test_package("MMcluster", reporter = "progress")
testthat::test_package("MMcluster", reporter = "progress")
usethis::use_test()
devtools::install()
testthat::test_package("MMcluster", reporter = "progress")
?test_check
lld
ldu
lld-ldu
?test_package
testthat::test_package("MMcluster", reporter = "debug")
for ( i in 1: num_sim){
mu[rand_idx,]<- runif(p)
ldu[i]<- nnm_post(mu, Sigma, rho[,1], y, V, theta, Z, vk, Omega)
lld[i] <- mu_k.post(theta, mu, Sigma, Z, rand_idx)
}
testthat::test_package("MMcluster", reporter = "progress")
testthat::test_package("MMcluster", reporter = "summary")
testthat::test_package("MMcluster", reporter = "fail")
testthat::test_package("MMcluster", reporter = "progress")
devtools::install()
testthat::test_package("MMcluster", reporter = "progress")
devtools::install()
testthat::test_package("MMcluster", reporter = "progress")
testthat::test_package("MMcluster", reporter = "debug")
devtools::install()
testthat::test_package("MMcluster", reporter = "progress")
testthat::test_package("MMcluster", reporter = "debug")
mu
Sigma
k
Z
z
Z
theta
mu
Z
rho
testthat::test_package("MMcluster", reporter = "debug")
testthat::test_package("MMcluster", reporter = "debug")
testthat::test_package("MMcluster", reporter = "debug")
rand_idx
sigma_k.post(theta,mu,Sigma,Z,rand_idx,vk,Omega = )
sigma_k.post(theta,mu,Sigma,Z,rand_idx,vk,Omega)
debug(sigma_k.post)
data<- sim_data(K, N, p)
rho <- data$rho
y <- data$y
V <-data$V
Z <- data$Z
theta <- data$theta
mu <-data$mu
Sigma <-data$Sigma
vk<-data$vk
Omega<-data$Omega
rand_idx<-as.integer(K*runif(1))
ldu<-rep(0, num_sim)
lld<-rep(0, num_sim)
for ( i in 1: num_sim){
new_Sigma <-matrix(runif(p*p)*2-1, nrow= p, ncol =p )
new_Sigma <- t(new_Sigma) %*% new_Sigma
Sigma[,,rand_idx] <- new_Sigma
ldu[i]<- nnm_post(mu, Sigma, rho[,1], y, V, theta, Z, vk, Omega)
lld[i] <- sigma_k.post(theta, mu, Sigma, Z, rand_idx, vk, Omega)
}
k
testthat::test_package("MMcluster", reporter = "debug")
testthat::test_package("MMcluster", reporter = "debug")
mu_k
theta_avg_k
k
?as.integer
as.integer(.4)
devtools::install()
testthat::test_package("MMcluster", reporter = "progress")
testthat::test_package("MMcluster", reporter = "debug")
mu_k
k
testthat::test_package("MMcluster", reporter = "debug")
testthat::test_package("MMcluster", reporter = "debug")
testthat::test_package("MMcluster", reporter = "debug")
testthat::test_package("MMcluster", reporter = "debug")
rand_idx
devtools::install()
testthat::test_package("MMcluster", reporter = "debug")
testthat::test_package("MMcluster", reporter = "progress")
testthat::test_package("MMcluster", reporter = "debug")
rand_idx
2
k
devtools::install()
testthat::test_package("MMcluster", reporter = "progress")
testthat::test_package("MMcluster", reporter = "debug")
rand_idx
devtools::install()
testthat::test_package()
testthat::test_package("MMcluster", reporter = "progress")
testthat::test_package("MMcluster", reporter = "progress")
testthat::test_package("MMcluster", reporter = "summary")
testthat::test_package("MMcluster", reporter = "debug")
library(testthat)
testthat::test_package("MMcluster", reporter = "debug")
data<- sim_data(K, N, p)
rho <- data$rho
y <- data$y
V <-data$V
Z <- data$Z
theta <- data$theta
mu <-data$mu
Sigma <-data$Sigma
vk<-data$vk
Omega<-data$Omega
ldu<-rep(0, num_sim)
lld<-rep(0, num_sim)
for ( i in 1: num_sim){
rho[,1]<-runif(K)
rho[,1]<-rho[,1]/sum(rho[,1])
ldu[i]<- nnm_post(mu, Sigma, rho[,1], y, V, theta, Z, vk, Omega)
lld[i] <- rho.post(Z, rho[,1])
}
difference <- lld-ldu
# iterate through all values of difference and make sure
# they are equal to the first value
for (diff_i in difference) {
test_that("rho posterior", {
expect_equal(diff_i, difference[1])
})
}
source('~/R/myPkgs/MMcluster/tests/testthat/test-update-functions.R', echo=TRUE)
source('~/R/myPkgs/MMcluster/tests/testthat/test-update-functions.R', echo=TRUE)
#' Random sampling from the Dirichlet distribution.
#'
#'
#' @param n Number of random draws.
#' @param alpha Weight parameter: a vector of nonnegative entries.
#' @return A matrix of size `n x length(alpha)` of which each row is a random draw.
rdirichlet <- function(n, alpha) {
K <- length(alpha) # number of categories
X <- matrix(rgamma(n*K, shape = alpha), K, n)
drop(t(sweep(X, 2, colSums(X), "/")))
}
#' Sample from a categorical distribution.
#'
#'
#' Performs one draw from a categorical distribution (i.e., a multinomial distribution with size `n = 1`) for each of multiple probability vectors.
#'
#' @param prob An `n_cat x n_prob` matrix of probability vectors, each of which is a column of `prob`.  The entries of `prob` must be nonnegative, but are internally normalized such that each column sums to one.
#' @return A vector of length `n_prob` of integers between 1 and `n_cat` indicating the category draw for each column of `prob`.
rcategorical <- function(prob) {
if(any(prob < 0)) stop("prob must contain only nonnegative entries.")
cprob <- apply(prob, 2, cumsum)
u <- runif(ncol(prob)) * cprob[nrow(prob),]
apply(sweep(cprob, 2, u) >= 0, 2, which.max)
}
#'
#'
#' Calculates `y = V^{-1} x` where `V` is a variance matrix.
#'
#' @param V Variance matrix.
#' @param x Optional vector or matrix for which to solve system of equations.  If missing calculates inverse matrix.
#' @param ldV Optionally compute log determinant as well.
#'
#' @return Either a matrix or vector `y = V^{-1} x`, or if `ldV = TRUE`, a list with elements `y` and `ldV = log(det(V))`.
#' @details This function is faster and more stable than `base::solve()` when `V` is known to be positive-definite.
solveV <- function(V, x, ldV = FALSE) {
C <- chol(V) # cholesky decomposition
if(missing(x)) x <- diag(nrow(V))
# solve is O(ncol(C) * ncol(x)) with triangular matrices
# using backward subsitution
ans <- backsolve(r = C, x = backsolve(r = C, x = x, transpose = TRUE))
if(ldV) {
ldV <- 2 * sum(log(diag(C)))
ans <- list(y = ans, ldV = ldV)
}
ans
}
source('~/R/myPkgs/MMcluster/tests/testthat/test-update-functions.R', echo=TRUE)
source('~/R/myPkgs/MMcluster/tests/testthat/test-update-functions.R', echo=TRUE)
devtools::install()
testthat::test_package("MMcluster", reporter = "progress")
devtools::install()
library(MMcluster)
MMcluster()
devtools::document()
testthat::test_package("MMcluster", reporter = "progress")
devtools::install()
testthat::test_package("MMcluster")
?MMcluster
devtools::document()
?MMcluster
devtools::document()
?MMcluster
devtools::document()
?MMcluster
?mniw
devtools::document()
?MMcluster
devtools::document()
?MMcluster
devtools::document()
?MMcluster
devtools::document()
?MMcluster
?`numDeriv-package`
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
setwd("~/GitHub")
hbe_fit <- readRDS("hbe-fbm_fit_v1.rds")
hbe_fit <- readRDS("hbe-fbm_fit_v1.rds")
N <- length(hbe_fit)
p <- length(hbe_fit[[1]]$coef)
# Extract data
wts <- vector(length=N)
theta_hat <- matrix(nrow=N, ncol=p)
obs_info <- array(dim=c(p, p, N))
for (i in 1:N){
theta_hat[i, ] <- hbe_fit[[i]]$coef
wts[i] <- hbe_fit[[i]]$wt
obs_info[, , i] <- hbe_fit[[i]]$vcov
}
# Transform the wts into numeric labels
lab <- unique(wts)
K <- length(lab)
cluster <- numeric(length=N)
for (i in 1:N){
if (wts[i] == lab[1]){
cluster[i] <- 1
}
else if (wts[i] == lab[2]){
cluster[i] <- 2
}
else if (wts[i] == lab[3]){
cluster[i] <- 3
}
else if (wts[i] == lab[4]){
cluster[i] <- 4
}
else if (wts[i] == lab[5]){
cluster[i] <- 5
}
else{
cluster[i] <- 6
}
}
real_N_k <- numeric(length=K)
for (k in 1:K){
real_N_k[k] <- sum(cluster == k)
}
theta_hat
?devtools::use_data
?data.frame
N <- length(hbe_fit)
p <- length(hbe_fit[[1]]$coef)
# Extract data
wts <- vector(length=N)
theta_hat <- matrix(nrow=N, ncol=p)
obs_info <- array(dim=c(p, p, N))
for (i in 1:N){
theta_hat[i, ] <- hbe_fit[[i]]$coef
wts[i] <- hbe_fit[[i]]$wt
obs_info[, , i] <- hbe_fit[[i]]$vcov
}
# Transform the wts into numeric labels
lab <- unique(wts)
K <- length(lab)
cluster <- numeric(length=N)
for (i in 1:N){
if (wts[i] == lab[1]){
cluster[i] <- 1
}
else if (wts[i] == lab[2]){
cluster[i] <- 2
}
else if (wts[i] == lab[3]){
cluster[i] <- 3
}
else if (wts[i] == lab[4]){
cluster[i] <- 4
}
else if (wts[i] == lab[5]){
cluster[i] <- 5
}
else{
cluster[i] <- 6
}
}
real_N_k <- numeric(length=K)
for (k in 1:K){
real_N_k[k] <- sum(cluster == k)
}
colnames(theta_hat) <- names(hbe_fit[[1]]$coef)
data.frame(cbind(theta_hat, cluster))
weights <- clusters
weights <- cluster
hbe <- data.frame(cbind(theta_hat, weights))
setwd("~/R/myPkgs/MMcluster")
devtools::use_data(hbe, obs_info)
?devtools
library(devtools)
use_data(hbe,obs_info)
names(hbe)
lab
hbe <- data.frame(cbind(theta_hat, wts))
use_data(hbe,obs_info)
use_data(hbe,obs_info, overwrite = TRUE)
devtools::document()
devtools::install()
devtools::check()
usethis::use_package_doc()
devtools::check()
?rgamma
?runif
?mniw
?var
devtools::document()
devtools::check()
?mod
devtools::document()
check()
usethis::use_gpl3_license()
?usethis::use_gpl3_license()
?usethis::use_gpl3_license(name = "Gregory Reid; José Dairo; Mark Christopher Uy; Thomas Yan")
?usethis::use_gpl3_license(name = "Gregory Reid; José Dairo; Mark Christopher Uy; Thomas Yan")
?
m
usethis::use_gpl3_license(name = "Gregory Reid; José Dairo; Mark Christopher Uy; Thomas Yan")
names(hbe)
document()
check()
document()
check()
summary(hbe)
document()
check()
document()
check()
?usethis::use_gpl3_license()
?hbe
document
document()
?hbe
document()
?hbe
document
document()
?hbe
document
document()
check()
build()
?usethis::use_gpl3_license
document
document()
document()
document
document()
document()
check()
check()
build()
